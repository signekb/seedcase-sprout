---
title: "Naming of Things"
---

{{< include ../_wip.qmd >}}

## Philosophy and ideals

How we name things, both internally and user-facing, will be:

- Simple: Keep the vocabulary simple and easy to understand
- Composable: Can be combined with other names to imply intent
- Predictable: Easy to guess and reason on, without needing to look up documentation
- Reusable: Can be used across multiple contexts
- Consistent: Remains the same across different contexts
- Align with existing conventions: Follow widely-established standards and conventions

## User-facing content

### Composing names

We'll compose names based on the objects we and our users interact with as well
as the actions taken on those objects. These objects and actions are inspired by
and align with the "core" language of working with data called *CRUD* (Create
Read Update Delete), common naming schemes used in REST API applications or
services (such as Github), as well as by the vocabulary of the HTTP verbs (GET,
POST, PUT, PATCH, and DELETE):

- Types of objects Sprout interacts with: projects, data, and metadata.
- Types of actions Sprout takes on those objects: create, view, update, and delete
- Types of identifiers for specific items of objects (as numbers): data, metadata, and project identifiers.

To name things, we'll combine the above with the object name first, followed by the
action, with a natural heirarchy of "offspring" to the objects. Based on these
principles, we can derive a naming scheme. In the scheme, objects and actions 
are ordered, with names occurring first acting as a "parent" to later
names. The names are separated by a symbol based on its context:

- `_` for Python function names.
- `-` for file path names.
- `/` for URLs and web API endpoint names (a `/` always begins each URL to act as a root, but never ends a URL).
- ` ` for command line interface names.

Additional "rules" to the naming include:

- When a naming scheme ends without an action, the default action is `view`.
- Data objects do not have any `view` action, since we want to limit access to looking at raw data.

### Scheme

Based on the above principles, we have defined the following naming scheme (here
shown with `space` as separator):

```
# View all projects
projects

# Create a new project
projects create

# View landing page of a specific project
projects <id> 

# Update or delete a specific project 
projects <id> update
projects <id> delete

# View all metadata objects of a specific project
projects <id> metadata

# Create a new metadata object with associated data in a 
# specific project
projects <id> metadata create
# This creates an associated data object at:
# projects <id> metadata <id> data

# View the landing page of a specific metadata object in 
# a specific project
projects <id> metadata <id>

# Update or delete metadata of a specific project
projects <id> metadata <id> update
projects <id> metadata <id> delete

# Update or delete data of a specific metadata object to 
# a specific project
projects <id> metadata <id> data update
projects <id> metadata <id> data delete
```
