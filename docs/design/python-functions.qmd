---
title: "Core Python functions"
---

{{< include /docs/includes/_wip.qmd >}}

Based on the [naming scheme](naming.qmd) and the [Frictionless Data Package standard](https://datapackage.org), these are the core
external-facing functions in Sprout, which are stored in `sprout/core/`.
See the [Outputs](outputs.qmd) section for an overview and explanation
of the different outputs provided by Sprout. 

There are some small differences between the naming scheme and
the functions described here:

1.  Whenever `view` is used, it is always for one object (either a
    package or a resource). Whenever `list` is used, it is
    always to show basic details of all existing objects of a given type (packages or resources). 
    Both `view` and `list` only ever show the information
    contained in the `datapackage.json` and never show actual data. 
    We don't provide the ability to view data
    directly since it is [out of scope](index.qmd#goals) of Sprout and we want to minimise
    any security and privacy risks. The IT admin and data package admin
    users can always view the data directly (outside of Sprout) 
    as they will have the appropriate IT and legal permissions.
2.  `edit` only ever edits the `datapackage.json` which contains the properties/metadata
    of the package or resource(s) but never edits the data itself. If there is a need for 
    updates to the data itself, the
    user can update it by uploading a new file with the updates (as long
    as the primary keys like participant ID and time of collection are
    the same). We don't provide access for users to directly edit the
    data because we want to limit security risks as well as to maintain
    privacy and legal compliance.
3.  `add` only ever adds more data to an existing data resource and does
    not add any new metadata to the `datapackage.json`. Since Sprout
    contains the full Frictionless Data specification, using `edit` is
    enough to make updates to the existing properties found in the
    `datapackage.json` file.

Nearly all functions have a `path` argument. Depending on
what the function does, the path object will be different. Use the
`path_*()` functions to get the correct path object for the specific
function. It's designed this way to make it more flexible to where
individual packages and resources are stored and to make it a bit easier
to write tests for the functions. For a similar reason, most of the
functions output either a JSON file or path object to make them easier
to test.

Several of the functions have an optional argument called `properties`.
The properties argument is a list of key-value pairs (as a JSON object) that describe the
package and resource(s) in the package. This metadata is stored in the `datapackage.json` file and
follows the Frictionless Data specification.

## Data package functions

`list_packages(path)`

:   This function lists some basic details contained in the
    `datapackage.json` files of all data packages found in the `path`
    location. This would be a list, showing very basic information that
    would be allowed by privacy and legal regulations (e.g. the
    package ID as well as the name, description, and contact persons for
    each package). Use `path_sprout_root()` to provide the path to the
    place packages are stored by default. Outputs a JSON object by
    default.

`view_package_properties(path)`

:   This will show the information contained within the
    `datapackage.json` file of a package for only the fields relevant to
    the package itself, and only basic details of the resources within the package. Use
    `path_properties()` to provide the correct path location.
    Outputs a JSON object.

`create_package_structure(path)`

:   This is the first function to use to create a new data package. It
    assigns a package ID and then creates a package folder and all the necessary files for a
    package (excluding the resources), as described in the
    [Outputs](outputs.qmd) section. Creates the files and then outputs
    the file paths for the created files. Use `path_package()` to
    provide the correct path location to create this structure.

`create_package_properties(path, properties)`

:   This is the second function to use to create a new data package. It
    is used to fill in the details in the `datapackage.json` file by
    using the `properties` argument which must be a JSON object.
  The `properties` argument must follow the Frictionless Data
    specification. To get a JSON object that follows the correct
    specification use `view_package_properties_template()`. Use
    `path_properties()` to provide the correct path location.
    Outputs a JSON object only. Use `write_package_properties()` to save
    back to the `datapackage.json` file.

`edit_package_properties(path, properties)`

:   Make edits to the `datapackage.json` properties of a specific
    package. Only edits metadata on the package itself, not on the data
    resources contained within the package. 
    The `properties` argument must follow the Frictionless Data
    specification. Use `view_package_properties_template()` to get a
    JSON object that follows the correct specification. Use
    `path_properties()` in the `path` argument to provide the
    correct location for the file. Outputs a JSON object only. Use
    `write_package_properties()` to save back to the `datapackage.json`
    file.

`delete_package(path, confirm)`

:   Completely delete a specific package and all it's data resources.
    Because this action would be permanent, the `confirm` argument
    would default to `false` so that the user needs to explicitly provide `true` to the function argument as confirmation.
    This is done to prevent accidental deletion.
    Use `path_package()` function in the `path` to
    get the correct location. Outputs `true` if the deletion was
    successful.

`write_package_properties(properties, path)`

:   Writes JSON object containing package properties (not including resource properties) back to the `datapackage.json` file.
    The `path` argument is the location of the `datapackage.json` file.
    Use the `path_properties()` function to provide this path to
    the correct location. Returns the same path object as given in the
    `path` argument.

## Data resource functions

`list_resources(path)`

:   This looks in one specific package's `datapackage.json` file and
    lists a basic summary of all the data resources contained within the
    package. The list would be basic information like resource ID, name,
    and description. Use `path_package()` to provide the correct path
    location. Outputs a JSON object.

`view_resource(path, properties_path)`

:   Views the information on a package's specific resource that is
    contained within the `datapackage.json` file. Use the
    `path_resource()` function to provide the correct location for the
    `path` and `path_properties()` for the `properties_path` argument.
    Outputs a JSON object.

`create_resource_structure(path)`

:   This is the first function to use to set up the structure for a data
    resource. It creates the paths for a new data resource in a specific (existing)
    package by creating the folder setup described in the
    [Outputs](outputs.qmd) section. Use the `path_resources()` function
    to provide the correct path location. It creates two paths:  the `resources/<id>/` 
    path and the `resources/<id>/raw/` path. The output is a list of these two path
    objects.

`create_resource_properties(path, data_path, properties)`

:   This function either takes the data found in the `data_path`
    location and creates a JSON object following the Frictionless Data
    standard or takes the `properties` argument to fill in the correct
    fields for the data resource in the `datapackage.json` file.

    If the `data_path` argument is given, it tries to guess and fill in
    some of the property fields required by the Frictionless Data
    resource specification. Use `edit_resource_properties()` to fill in
    any missing fields.

    If the `data_path` argument is not given, the `properties` argument
    is required and is used to directly provide the properties values
    for the resource in the `datapackage.json` file. It must be given a
    a JSON object (use `view_resource_properties_template()` to have the
    correct JSON object).

    Use `path_resource()` to provide the correct `path` location or use the output
    of `create_resource_structure()`. Outputs
    a JSON object only; use `write_resource_properties()` to save the JSON object
    to the `datapackage.json` file.

`write_resource_data_to_raw(path, data_path)`

:   Copy the file from `data_path` over into the resource location given
    by `path`. This will compress the file and use a timestamped, unique
    file name to store it as a backup. See the explanation of this file in
    the [Outputs](outputs.qmd) section. Use `path_resource_raw()`
    to provide the correct `path` location. Copies and compresses the file, and outputs
    the path object of the created file.

`write_resource_parquet(raw_files, path)`

:   This function takes the files provided by `raw_files` and merges them
    into a `data.parquet` file provided by `path`. Use
    `path_resource_data()` to provide the correct path location for
    `path` and `path_resources_raw_files()` for the `raw_files` argument.
    Outputs the path object of the created file.

`edit_resource_properties(path, properties)`

:   Edit the properties of a resource in a package. The `properties`
    argument must be a JSON object that follows the Frictionless Data
    specification. Use the
    `path_properties()` function to provide the correct path
    location. Outputs a JSON object only; use
    `write_resource_properties()` to save the JSON object to the `datapackage.json`
    file.

`delete_resource_raw_file(path, confirm)`

:   Use this to delete a raw file in the `raw/` folder of a resource.
    This is useful if the file is no longer needed or if it is incorrect
    or had an issue during the time when a user first added the file
    to a resource. Use `path_resource_raw_files()` to select which file
    to delete from the list of files found. Will only delete one file. The
    `confirm` argument defaults to `false` so that the user needs to explicitly provide `true` to the function argument as confirmation.
    This is done to prevent accidental deletion.
    Outputs `true` if the deletion
    was successful.

`delete_resource_data(path, confirm)`

:   Delete all data (Parquet and in the database) and raw data of a specific resource. Use
    `path_resource_raw()` to provide the correct path location. The
    `confirm` argument defaults to `false` so that the user needs to explicitly provide `true` to the function argument as confirmation.
    This is done to prevent accidental deletion.
    Outputs `true` if the deletion
    was successful. Use `delete_resource_properties()` to delete the the
    associated properties/metadata for the resource.

`delete_resource_properties(path, confirm)`

:   Deletes all properties for a resource within the `datapackage.json`
    file. Use `path_properties()` to provide the correct
    location for `path`. The `confirm` argument defaults to `false` so that the user needs to explicitly provide `true` to the function argument as confirmation.
    This is done to prevent accidental deletion.
    Outputs
    `true` if the deletion was successful.

`write_resource_properties(properties, path)`

:   Use to write the resource JSON object back to the `datapackage.json` file.
    This function validates whether the JSON object follows the Data Package resource specification.
    The `path` argument is the location of the `datapackage.json` file.
    Use the `path_properties()` function to provide this path to
    the correct location. Returns the same path object as given in the
    `path` argument.
 

`write_resource_to_database(data, path, properties)`

:   Writes a data object to the `path` database location. Use
    `path_resource_database()` to provide the correct location for the
    `path` object. The `properties` argument, using `view_resource()`,
    ensures the correct table is created in the database. Outputs the
    same `path` object as well as the name of the newly created database
    table.

## Path functions

::: callout-warning
These functions are still being developed.
:::

`path_resources(package_id)`

:   TODO

`path_resource(package_id, resource_id)`

:   TODO

`path_resource_raw(package_id, resource_id)`

:   TODO

`path_resource_raw_files(package_id, resource_id)`

:   TODO

`path_resource_data(package_id, resource_id)`

:   TODO

`path_properties(package_id)`

:   TODO

`path_package_database(package_id)`

:   TODO

`path_package(package_id)`

:   TODO

`path_sprout_root(package_id)`

:   TODO

## Helper functions

::: callout-warning
These functions are still being developed.
:::

`pretty_json(json)`

:   Create a prettier, human readable version of a JSON object.

`create_package_properties_template()`

:   TODO

`create_resource_properties_template()`

:   TODO

`view_properties()`

:   TODO. Outputs a JSON object.

`view_package_properties_template()`

:   TODO. Outputs a JSON object.

`view_resource_properties_template()`

:   TODO. Outputs a JSON object.

## Observational unit level functions

Observational unit is the level of detail on the entity (e.g. human, animal, event) that the data was collected on. Example would be: A person in a research study who came to the clinic in May 2024 to have their blood collected and to fill out a survey.

`delete_participant_data()`

: TODO.
